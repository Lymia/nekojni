mod method_handler;

use crate::{errors::*, utils::*, MacroCtx};
use darling::FromAttributes;
use nekojni_signatures::ClassName;
use proc_macro2::{Ident, TokenStream};
use quote::quote;
use syn::{parse2, spanned::Spanned, ImplItem, ItemImpl, Type};

pub(crate) struct JavaClassCtx {
    class_name: TokenStream,
    class_name_str: String,
    settings: MacroArgs,
    sym_uid: usize,

    generated_impls: TokenStream,
    generated_private_impls: TokenStream,
    generated_type_checks: TokenStream,
    generated_cache: TokenStream,

    fn_get_exports: TokenStream,
    fn_get_native_methods: TokenStream,
}
impl JavaClassCtx {
    fn gensym(&mut self, prefix: &str) -> Ident {
        let ident = ident!("nekojni__{}_{}", prefix, self.sym_uid);
        self.sym_uid += 1;
        ident
    }
}

#[derive(Debug, FromAttributes)]
#[darling(attributes(jni))]
pub(crate) struct MacroArgs {
    #[darling(default)]
    package: Option<String>,
    #[darling(default)]
    java_name: Option<String>,
    #[darling(default)]
    java_path: Option<String>,
}

fn jni_process_impl(attr: TokenStream, item: TokenStream, is_import: bool) -> Result<TokenStream> {
    let ctx = MacroCtx::new()?;
    let mut impl_block = parse2::<ItemImpl>(item)?;

    if impl_block.generics.params.iter().next().is_some() {
        error(
            impl_block.generics.span(),
            "`#[jni_exports]` may not be used with generic impls.",
        )?;
    }

    // Process macros on the impl block
    let args: MacroArgs = FromAttributes::from_attributes(&impl_block.attrs)?;
    for attr in &mut impl_block.attrs {
        if last_path_segment(&attr.path) == "jni" {
            mark_attribute_processed(attr);
        }
    }

    // Derive the class name and some other useful fields.
    let class_name = match &args.java_path {
        Some(path) => {
            if !args.package.is_none() {
                error(
                    attr.span(),
                    "`#[jni(java_path = ...)]` and `#[jni(package = ...)]` are mutually exclusive.",
                )?
            }
            path.clone()
        }
        None => {
            let class_simple_name = match &args.java_name {
                None => match &*impl_block.self_ty {
                    Type::Path(ty) => last_path_segment(&ty.path),
                    _ => error(
                        impl_block.self_ty.span(),
                        "Cannot automatically retrieve java_name for this path. \
                        Please use `#[jni(java_name = \"ExplicitName\")]`",
                    )?,
                },
                Some(name) => name.clone(),
            };
            let package_str = args.package.clone().unwrap_or_else(String::new);
            let package_dot = if package_str.is_empty() { "" } else { "." };
            format!("{package_str}{package_dot}{class_simple_name}")
        }
    };
    let class_name = match ClassName::parse_java(&class_name) {
        Ok(v) => v,
        Err(e) => error(attr.span(), format!("Could not parse class name: {e:?}"))?,
    };

    // Build the context.
    let class_name_toks = crate::signatures::dump_class_name(&ctx, &class_name);
    let mut components = JavaClassCtx {
        class_name: class_name_toks.clone(),
        class_name_str: class_name.display_jni().to_string(),
        settings: args,
        sym_uid: 0,
        generated_impls: Default::default(),
        generated_private_impls: Default::default(),
        generated_type_checks: Default::default(),
        generated_cache: Default::default(),
        fn_get_exports: Default::default(),
        fn_get_native_methods: Default::default(),
    };

    // Process methods in the impl block
    let mut errors = Error::empty();
    for item in std::mem::replace(&mut impl_block.items, Vec::new()) {
        match item {
            ImplItem::Method(mut method) => {
                match method_handler::method_wrapper(&ctx, &mut components, &mut method) {
                    Ok(true) => { /* remove this method */ }
                    Ok(false) => impl_block.items.push(ImplItem::Method(method)),
                    Err(e) => errors = errors.combine(e),
                }
            }
            item => impl_block.items.push(item),
        }
    }
    if !errors.is_empty() {
        return Err(errors);
    }

    // Create the actual impl block
    let nekojni = &ctx.nekojni;
    let nekojni_internal = &ctx.internal;
    let std = &ctx.std;
    let jni = &ctx.jni;

    let impl_ty = &impl_block.self_ty;

    let generated_impls = &components.generated_impls;
    let generated_private_impls = &components.generated_private_impls;
    let generated_type_checks = &components.generated_type_checks;
    let generated_cache = &components.generated_cache;

    Ok(quote! {
        #impl_block

        /// New code generated by nekojni.
        #[allow(deprecated)]
        const _: () = {
            #[derive(Default)]
            pub struct ExportedClassCache<'env> {
                #generated_cache
                _phantom: #std::marker::PhantomData<&'env ()>,
            }

            impl #impl_ty {
                #generated_impls
            }
            impl<'env> #nekojni_internal::JavaClassImpl<'env> for #impl_ty {
                const JAVA_TYPE: #nekojni::signatures::Type<'static> =
                    #nekojni::signatures::Type::new(
                        #nekojni::signatures::BasicType::Class(#class_name_toks)
                    );
                const CLASS_INFO: Option<#nekojni_internal::exports::ExportedClass> = None;
                fn register_methods(&self, env: #nekojni::JniEnv) -> #nekojni::Result<()> {
                    // TODO: register_methods
                    #nekojni::Result::Ok(())
                }
                fn default_ptr() -> &'static Self {
                    #nekojni_internal::default_ptr_fail()
                }
                fn create_jni_ref(
                    env: #nekojni::JniEnv<'env>,
                    obj: #jni::objects::JObject<'env>,
                ) -> #nekojni::Result<#nekojni::JniRef<'env, Self>>
                    where Self: #nekojni::objects::JavaClass<'env>
                {
                    #nekojni_internal::jni_ref::new_rust(env, obj)
                }
                type Cache = ExportedClassCache<'env>;
            }
            impl<'env> #nekojni::objects::JavaClass<'env> for #impl_ty { }
            impl<'env> #nekojni_internal::RustContents<'env> for #impl_ty {
                const ID_FIELD: &'static str = "njit$$i";
            }

            #[allow(unused)]
            mod nekojni__private {
                use super::*;
                impl #impl_ty {
                    #generated_private_impls
                }
            }

            #[allow(unused)]
            mod nekojni__type_check {
                use super::*;
                impl #impl_ty {
                    fn nekojni__macro_generated_type_checks() {
                        #generated_type_checks
                    }
                }
            }

            ()
        };
    })
}

pub fn jni_export(attr: TokenStream, item: TokenStream) -> Result<TokenStream> {
    jni_process_impl(attr, item, false)
}
pub fn jni_import(attr: TokenStream, item: TokenStream) -> Result<TokenStream> {
    jni_process_impl(attr, item, true)
}
